<p align="center"><img src="images/devops_exercises.png"/></p>

:information_source: &nbsp;此存储库包含有关各种技术主题的问题和练习，有时与 DevOps 和 SRE 相关

:bar_chart: &nbsp;当前有 **2624** 个问题

:warning: &nbsp;您可以使用这些来准备面试，但大多数问题和练习并不代表实际的面试。请阅读[常见问题](faq.md)了解更多详情` ```

:page_facing_up: &nbsp;不同的面试官专注于不同的事情。 有些人将重点放在你的简历上，而另一些人可能将重点放在方案问题或特定的技术问题上。 在这个仓库，我尽力覆盖各种类型的 DevOps 问题，供你练习和测试你的知识

:pencil: &nbsp;你可以通过提交拉取请求来添加更多练习:) 在[此处](CONTRIBUTING.md)阅读贡献指南

****

<!-- ALL-TOPICS-LIST:START -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<center>
<table>
  <tr>
    <td align="center"><a href="topics/devops/README.md"><img src="images/devops.png" width="75px;" height="75px;" alt="DevOps" /><br /><b>DevOps</b></a></td>
    <td align="center"><a href="topics/git/README.md"><img src="images/git.png" width="75px;" height="75px;" alt="Git"/><br /><b>Git</b></a></td>
    <td align="center"><a href="#network"><img src="images/network.png" width="75px;" height="75px;" alt="Network"/><br /><b>Network</b></a></td>
    <td align="center"><a href="#hardware"><img src="images/hardware.png" width="75px;" height="75px;" alt="Hardware"/><br /><b>Hardware</b></a></td>
    <td align="center"><a href="topics/kubernetes/README.md"><img src="images/kubernetes.png" width="75px;" height="75px;" alt="kubernetes"/><br /><b>Kubernetes</b></a></td>
  </tr>

  <tr>
    <td align="center"><a href="topics/software_development/README.md"><img src="images/programming.png" width="75px;" height="75px;" alt="programming"/><br /><b>Software Development</b></a></td>
    <td align="center"><a href="https://github.com/bregman-arie/python-exercises"><img src="images/python.png" width="75px;" height="75px;" alt="Python"/><br /><b>Python</b></a></td>
    <td align="center"><a href="https://github.com/bregman-arie/go-exercises"><img src="images/Go.png" width="75px;" height="75px;" alt="go"/><br /><b>Go</b></a></td>
    <td align="center"><a href="topics/perl/README.md"><img src="images/perl.png" width="75px;" height="75px;" alt="perl"/><br /><b>Perl</b></a></td>
    <td align="center"><a href="#regex"><img src="images/regex.png" width="75px;" height="75px;" alt="RegEx"/><br /><b>Regex</b></a></td>
  </tr>

  <tr>
      <td align="center"><a href="topics/cloud/README.md"><img src="images/cloud.png" width="75px;" height="75px;" alt="Cloud"/><br /><b>Cloud</b></a></td>
      <td align="center"><a href="topics/aws/README.md"><img src="images/aws.png" width="100px;" height="75px;" alt="aws"/><br /><b>AWS</b></a></td>
      <td align="center"><a href="topics/azure/README.md"><img src="images/azure.png" width="75px;" height="75px;" alt="azure"/><br /><b>Azure</b></a></td>
      <td align="center"><a href="topics/gcp/README.md"><img src="images/googlecloud.png" width="70px;" height="70px;" alt="Google Cloud Platform"/><br /><b>Google Cloud Platform</b></a></td>
      <td align="center"><a href="#openstack/README.md"><img src="images/openstack.png" width="75px;" height="75px;" alt="openstack"/><br /><b>OpenStack</b></a></td>
  </tr>

  <tr>
      <td align="center"><a href="#operating-system"><img src="images/os.png" width="75px;" height="75px;" alt="Operating System"/><br /><b>Operating System</b></a></td>
      <td align="center"><a href="topics/linux/README.md"><img src="images/logos/linux.png" width="75px;" height="75px;" alt="Linux"/><br /><b>Linux</b></a></td>
      <td align="center"><a href="#virtualization"><img src="images/virtualization.png" width="75px;" height="75px;" alt="Virtualization"/><br /><b>Virtualization</b></a></td>
      <td align="center"><a href="topics/dns/README.md"><img src="images/dns.png" width="75px;" height="75px;" alt="DNS"/><br /><b>DNS</b></a></td>
      <td align="center"><a href="topics/shell/README.md"><img src="images/bash.png" width="75px;" height="75px;" alt="Bash"/><br /><b>Shell Scripting</b></a></td>
  </tr>

  <tr>
      <td align="center"><a href="topics/databases/README.md"><img src="images/databases.png" width="75px;" height="75px;" alt="Databases"/><br /><b>Databases</b></a></td>
      <td align="center"><a href="#sql"><img src="images/sql.png" width="75px;" height="75px;" alt="sql"/><br /><b>SQL</b></a></td>
      <td align="center"><a href="#mongo"><img src="images/mongo.png" width="75px;" height="75px;" alt="Mongo"/><br /><b>Mongo</b></a></td>
      <td align="center"><a href="#testing"><img src="images/testing.png" width="75px;" height="75px;" alt="Testing"/><br /><b>Testing</b></a></td>
      <td align="center"><a href="#big-data"><img src="images/big-data.png" width="75px;" height="75px;" alt="Big Data"/><br /><b>Big Data</b></a></td>

  </tr>

  <tr>
      <td align="center"><a href="topics/cicd/README.md"><img src="images/cicd.png" width="75px;" height="75px;" alt="cicd"/><br /><b>CI/CD</b></a></td>
      <td align="center"><a href="#certificates"><img src="images/certificates.png" width="75px;" height="75px;" alt="Certificates"/><br /><b>Certificates</b></a></td>
      <td align="center"><a href="topics/containers/README.md"><img src="images/containers.png" width="75px;" height="75px;" alt="Containers"/><br /><b>Containers</b></a></td>
      <td align="center"><a href="topics/openshift/README.md"><img src="images/openshift.png" width="75px;" height="75px;" alt="OpenShift"/><br /><b>OpenShift</b></a></td>
      <td align="center"><a href="#storage"><img src="images/storage.png" width="75px;" height="75px;" alt="Storage"/><br /><b>Storage</b></a></td>
  </tr>

  <tr>
      <td align="center"><a href="topics/terraform/README.md"><img src="images/terraform.png" width="75px;" height="75px;" alt="Terraform"/><br /><b>Terraform</b></a></td>
      <td align="center"><a href="#puppet"><img src="images/puppet.png" width="75px;" height="75px;" alt="puppet"/><br /><b>Puppet</b></a></td>
      <td align="center"><a href="#distributed"><img src="images/distributed.png" width="75px;" height="75px;" alt="Distributed"/><br /><b>Distributed</b></a></td>
      <td align="center"><a href="#questions-you-ask"><img src="images/you.png" width="75px;" height="75px;" alt="you"/><br /><b>Questions you can ask</b></a></td>
      <td align="center"><a href="topics/ansible/README.md"><img src="images/ansible.png" width="75px;" height="75px;" alt="ansible"/><br /><b>Ansible</b></a></td>
  </tr>

  <tr>
      <td align="center"><a href="topics/observability/README.md"><img src="images/observability.png" width="75px;" height="75px;" alt="observability"/><br /><b>Observability</b></a></td>
      <td align="center"><a href="#prometheus"><img src="images/prometheus.png" width="75px;" height="75px;" alt="Prometheus"/><br /><b>Prometheus</b></a></td>
      <td align="center"><a href="topics/circleci/README.md"><img src="images/logos/circleci.png" width="70px;" height="70px;" alt="Circle CI"/><br /><b>Circle CI</b></a></td>
      <td align="center"><a href="topics/datadog/README.md"><img src="images/logos/datadog.png" width="80px;" height="80px;" alt="DataDog"/><br /><b></b></a></td>
      <td align="center"><a href="topics/grafana/README.md"><img src="images/logos/grafana.png" width="80px;" height="80px;" alt="Grafana"/><br /><b>Grafana</b></a></td>
  </tr>

  <tr>
    <td align="center"><a href="topics/argo/README.md"><img src="images/logos/argo.png" width="80px;" height="80px;" alt="Argo"/><br /><b>Argo</b></a></td>
    <td align="center"><a href="topics/soft_skills/README.md"><img src="images/HR.png" width="75px;" height="75px;" alt="HR"/><br /><b>Soft Skills</b></a></td>
    <td align="center"><a href="topics/security/README.md"><img src="images/security.png" width="75px;" height="75px;" alt="security"/><br /><b>Security</b></a></td>
    <td align="center"><a href="#system-design"><img src="images/design.png" width="75px;" height="75px;" alt="Design"/><br /><b>System Design</b></a></td>
   </tr>

   <tr>
    <td align="center"><a href="topics/chaos_engineering/README.md"><img src="images/logos/chaos_engineering.png" width="75px;" height="75px;" alt="Chaos Engineering"/><br /><b>Chaos Engineering</b></a></td>
    <td align="center"><a href="#Misc"><img src="images/general.png" width="75px;" height="75px;" alt="Misc"/><br /><b>Misc</b></a></td>
    <td align="center"><a href="#elastic"><img src="images/elastic.png" width="75px;" height="75px;" alt="Elastic"/><br /><b>Elastic</b></a></td>
    <td align="center"><a href="topics/kafka/README.md"><img src="images/logos/kafka.png" width="85px;" height="80px;" alt="Kafka"/><br /><b>Kafka</b></a></td>
   </tr>

</table>
</center>
<!-- markdownlint-enable -->
<!-- prettier-ignore-end -->
<!-- ALL-TOPICS-LIST:END -->

## 网络

<details>
<summary>一般来说，你需要什么才能进行交流？</summary><br><b>

  - 一种共同的语言（供两端理解）
  - 与你想要沟通的人交流的方法
  - 一个连接（以便通信内容能够到达接收者）

</b></details>

<details>
<summary>什么是 TCP/IP？</summary><br><b>

一组协议，定义了两个或多个设备如何相互通信。

了解更多关于TCP/IP, 阅读 [这里](http://www.penguintutor.com/linux/basic-network-reference)

</b></details>

<details>
<summary>什么是以太网？</summary><br><b>

以太网简单地指的是当今最常见的局域网（LAN）类型。与跨越较大地理区域的广域网（WAN）相对，LAN是一个连接在小范围内的计算机网络，比如你的办公室、大学校园或者家庭。

</b></details>

<details>
<summary>什么是 MAC 地址？它有什么用途？</summary><br><b>

MAC地址是用于识别网络上各个设备的唯一标识号码或代码。

通过以太网发送的数据包始终来自一个 MAC 地址并发送到一个 MAC 地址。如果网络适配器接收到一个数据包，它会将该数据包的目标 MAC 地址与适配器自身的 MAC 地址进行比较。

</b></details>

<details>
<summary>这个 MAC 地址是在什么时候使用的？: ff:ff:ff:ff:ff:ff</summary><br><b>

当设备向广播 MAC 地址（FF:FF:FF:FF:FF:FF）发送数据包时，它会传递给本地网络上的所有站点。以太网广播用于在数据链路层通过 ARP 解析 IP 地址到 MAC 地址。
</b></details>

<details>
<summary>什么是 IP 地址？</summary><br><b>

互联网协议地址（IP 地址）是分配给连接到使用互联网协议进行通信的计算机网络上的每个设备的数字标签。IP地址具有两个主要功能：主机或网络接口识别和位置寻址。
</b></details>

<details>
<summary>解释子网掩码并举例说明</summary><br><b>

子网掩码是一个32位的数字，用于屏蔽 IP 地址并将 IP 地址分为网络地址和主机地址。子网掩码通过将网络位设置为全部"1"，将主机位设置为全部"0"来生成。在给定的网络中，总可用主机地址中始终保留两个用于特定目的，并且不能分配给任何主机。这些是第一个地址，被保留作为网络地址（也称为网络 ID），以及最后一个用于网络广播的地址。

[例子](https://github.com/philemonnwanne/projects/tree/main/exercises/exe-09)

</b></details>

<details>
<summary>私有 IP 地址是什么？在哪些场景/系统设计中应该使用它？</summary><br><b>
私有IP地址被分配给同一网络中的主机，以便彼此通信。正如“私有”这个名字所暗示的那样，拥有私有IP地址的设备无法被来自任何外部网络的设备访问到。例如，如果我住在一个宿舍，并且我希望我的室友们加入我托管的游戏服务器，我会要求他们通过我的服务器的私有IP地址加入，因为该网络是局域网。
</b></details>

<details>
<summary>什么是公共 IP 地址？在哪些场景/系统设计中，应该使用它？</summary><br><b>
公共IP地址是面向公众的 IP 地址。如果你正在托管一个游戏服务器，希望你的朋友加入，你会给他们提供你的公共IP地址，以便他们的计算机能够识别和定位到你的网络和服务器，从而进行连接。在与与您连接到同一网络的朋友玩耍时，并不需要使用面向公众的IP地址，在这种情况下，您将使用私有IP地址。为了使某人能够连接到内部位置的服务器上，您需要设置端口转发来告诉路由器允许来自公共域名和网络之间的流量通信。
</b></details>

<details>
<summary>解释 OSI 模型。有哪几层？每层负责什么？</summary><br><b>

- 应用程序：用户端（ HTTP 在此）。
- 演示：建立应用层实体之间的上下文（加密在这里）。
- 会话：建立、管理和终止连接。
- 传输：将可变长度的数据序列从源主机传输到目标主机（ TCP 和 UDP 在此）。
- 网络：将数据报从一个网络传输到另一个网络（ IP 在此）。
- 数据链路：提供两个直接连接的节点之间的链接（MAC在此）。
- 物理特性：数据连接的电气和物理规格（位数在此）。

您可以在 [penguintutor.com](http://www.penguintutor.com/linux/basic-network-reference) 阅读有关OSI模型的更多信息。
</b></details>

<details>
<summary>对于以下每个确定其属于哪个 OSI 层：

  * 错误更正
  * 数据包路由
  * 电缆和电信号
  * MAC 地址
  * IP 地址
  * 终止连接
  * 3 次握手</summary><br><b>
  * 错误纠正 - 数据链路
  * 数据包路由 - 网络
  * 电缆和电信号 - 物理
  * MAC 地址 - 数据链路
  * IP 地址 - 网络
  * 终止连接 - 会话
  * 3次握手 - 传输
</b></details>

<details>
<summary>你熟悉哪些交付计划？</summary><br><b>

单播：一对一的通信，其中有一个发送者和一个接收者。

广播：向网络中的所有人发送消息。地址 ff:ff:ff:ff:ff:ff 用于广播。
           使用广播的两个常见协议是 ARP 和 DHCP。

多播：向一组订阅者发送消息。它可以是一对多或多对多的。
</b></details>

<details>
<summary>什么是 CSMA/CD？它在现代以太网网络中使用吗？</summary><br><b>

CSMA/CD 代表载波侦听多路访问冲突检测。
其主要目标是管理对共享介质/总线的访问，每次只有一个主机可以传输。

CSMA/CD 算法：

1. 在发送帧之前，它会检查是否有另一个主机正在传输帧。
2. 如果没有人在传输，它就开始传输帧。
3. 如果两个主机同时传输，就会发生碰撞。
4. 两个主机都停止发送帧，并向所有人发送一个“干扰信号”，通知大家发生了碰撞。
5. 他们正在等待一个随机的时间再次发送它。
6. 一旦每个主机等待了随机时间，它们会再次尝试发送帧，从而重新开始循环。
</b></details>

<details>
<summary>描述以下网络设备及其之间的区别：

  * 路由器
  * 交换机
  * 集线器</summary><br><b>

路由器、交换机和集线器都是用于连接局域网（LAN）中的设备的网络设备。然而，每个设备的操作方式不同，并且具有其特定的使用情况。以下是对每个设备及其之间区别的简要描述：

1. 路由器：一种网络设备，用于连接多个网络段。它在OSI模型的网络层（第3层）上运行，并使用路由协议来指导网络之间的数据传输。路由器使用IP地址来识别设备并将数据包定向到正确的目标位置。
2. 交换机：一种网络设备，用于连接局域网上的多个设备。它在OSI模型的数据链路层（第二层）工作，并使用MAC地址来识别设备并将数据包定向到正确的目标。交换机可以使同一网络上的设备更高效地相互通信，并且可以防止多个设备同时发送数据时可能发生的数据碰撞。
3. 集线器：一种网络设备，通过单根电缆连接多个设备，并用于在不分割网络的情况下连接多个设备。然而，与交换机不同的是，它在OSI模型的物理层（第1层）上运行，并且只是将数据包广播到所有连接到它的设备，无论该设备是否为预期接收者。这意味着可能会发生数据碰撞，并且网络效率可能因此受到影响。由于交换机更高效并提供更好的网络性能，所以现代网络设置通常不使用集线器。
</b></details>

<details>
<summary>什么是“冲突域”？</summary><br><b>
冲突域是一个网络段，在这个网络段中，设备可能会因为试图同时传输数据而相互干扰。当两个设备同时传输数据时，可能会发生碰撞，导致数据丢失或损坏。在冲突域中，所有设备共享同样的带宽，并且任何设备都有可能干扰其他设备的数据传输。
</b></details>

<details>
<summary>什么是“广播域”？</summary><br><b>
广播域是一个网络段，其中所有设备可以通过发送广播消息相互通信。广播消息是一条发送给网络中所有设备而不是特定设备的消息。在广播域中，所有设备都可以接收和处理广播消息，无论该消息是否针对它们。
</b></details>

<details>
<summary>连接到一个交换机的三台计算机。有多少个冲突域？有多少个广播域？</summary><br><b>

三个冲突域和一个广播域
</b></details>

<details>
<summary>路由器是如何工作的？</summary><br><b>

路由器是一种物理或虚拟设备，用于在两个或多个分组交换的计算机网络之间传递信息。路由器检查给定数据包的目标互联网协议地址（IP地址），计算它到达目的地的最佳路径，然后相应地转发它。

</b></details>

<details>
<summary>什么是NAT？</summary><br><b>

网络地址转换（NAT）是一个过程，其中一个或多个本地IP地址被翻译成一个或多个全局IP地址，反之亦然，以便为本地主机提供互联网访问。

</b></details>

<details>
<summary>什么是代理？它是如何工作的？我们为什么需要它？</summary><br><b>

代理服务器充当您和互联网之间的网关。它是一个中介服务器，将最终用户与他们浏览的网站分离开来。

如果您使用代理服务器，互联网流量将通过代理服务器传输到您请求的地址。然后，该请求再次通过相同的代理服务器返回（有一些例外情况），然后代理服务器将从网站接收到的数据转发给您。

代理服务器根据您的使用情况、需求或公司政策提供不同级别的功能、安全性和隐私保护。
</b></details>

<details>
<summary>TCP 是什么？它如何工作？三次握手是什么？</summary><br><b>

TCP 三次握手，又称为三向握手，在 TCP/IP 网络中用于建立服务器和客户端之间的连接的过程。

三次握手主要用于创建 TCP 套接字连接。它在以下情况下起作用：

- 一个客户节点通过IP网络向同一网络或外部网络上的服务器发送SYN数据包。该数据包的目标是询问/推断服务器是否对新连接开放。
- 目标服务器必须具有可以接受和发起新连接的开放端口。当服务器从客户节点收到SYN数据包时，它会响应并返回确认收据 - ACK 数据包或 SYN/ACK 数据包。
- 客户端节点接收到来自服务器的 SYN/ACK，并用一个 ACK数据包作出响应。
</b></details>

<details>
<summary>什么是往返延迟或往返时间？</summary><br><b>

摘自 [维基百科](https://en.wikipedia.org/wiki/Round-trip_delay)："发送信号所需的时间加上收到信号确认所需的时间"。

附加问题：局域网的 RTT 是多少？
</b></details>

<details>
<summary>SSL 握手是如何进行的？</summary><br><b>
SSL 握手是在客户端和服务器之间建立安全连接的过程。

1. 客户端向服务器发送一个Client Hello消息，其中包括客户端的SSL/TLS协议版本、客户端支持的加密算法列表和一个随机值。
2. 服务器响应一个Server Hello消息，其中包括服务器的SSL/TLS协议版本、一个随机值和会话ID。
3. 服务器发送一个证书消息，其中包含了服务器的证书。
4. 服务器发送 Server Hello Done 信息，表示服务器已完成服务器 Hello 阶段的信息发送。
5. 客户发送包含客户公钥的客户密钥交换信息。
6. 客户端发送 "更改密码规格 "报文，通知服务器客户端即将发送使用新密码规格加密的报文。
7. 客户端发送一个加密的握手消息，其中包含使用服务器的公钥加密的预主密钥。
8. 服务器发送 "更改密码规格 "信息，通知客户端服务器即将发送使用新密码规格加密的信息。
9. 服务器发送加密握手信息，其中包含用客户机公钥加密的预主密钥。
10. 客户端和服务器现在可以交换应用数据。
</b></details>

<details>
<summary>TCP 和 UDP 有什么区别？</summary><br><b>

TCP 在客户端和服务器之间建立连接，以保证数据包的顺序，而 UDP 不在客户端和服务器之间建立连接，也不处理数据包顺序。这使得 UDP 比 TCP 更轻便，是流媒体等服务的理想选择。

[Penguintutor.com](http://www.penguintutor.com/linux/basic-network-reference) 提供了很好的解释。
</b></details>

<details>
<summary>您熟悉哪些 TCP/IP 协议？</summary><br><b>
</b></details>

<details>
<summary>解释“默认网关”</summary><br><b>

默认网关是一个接入点或 IP 路由器，联网计算机利用它将信息发送到另一个网络或互联网上的计算机。
</b></details>

<details>
<summary>什么是 ARP？它是如何工作的？</summary><br><b>

ARP 是地址解析协议（Address Resolution Protocol）的缩写。当您尝试 ping 本地网络上的一个 IP 地址（如 192.168.1.1）时，您的系统必须将 IP 地址 192.168.1.1 转换为 MAC 地址。这就需要使用 ARP 来解析该地址，ARP 也因此而得名。

系统会保存一个 ARP 查找表，其中存储了哪些 IP 地址与哪些 MAC 地址相关联的信息。当试图向某个 IP 地址发送数据包时，系统会首先查询该表，看是否已经知道该 MAC 地址。如果有缓存值，则不使用 ARP。
</b></details>

<details>
<summary>什么是 TTL？它有助于防止什么？</summary><br><b>

- TTL（生存时间）是IP（Internet Protocol，互联网协议）数据包中的一个值，它决定了在被丢弃之前数据包可以经过多少跳或路由器。每次通过路由器转发数据包时，TTL值会减少一。当TTL值达到零时，数据包将被丢弃，并向发送方发送ICMP（Internet Control Message Protocol，互联网控制消息协议）消息以指示该数据包已过期。
- TTL 用于防止数据包在网络中无限循环，否则会造成拥塞并降低网络性能。
- 它还有助于防止数据包陷入路由环路，即数据包在同一组路由器之间不断往返而永远无法到达目的地。
- 此外，TTL 还可用于帮助检测和防止 IP 欺骗攻击，在这种攻击中，攻击者试图通过使用虚假或伪造的 IP 地址来冒充网络上的其他设备。通过限制数据包的跳数，TTL 可以帮助防止数据包被路由到不合法的目的地。
</b></details>

<details>
<summary>什么是 DHCP？它是如何工作的？</summary><br><b>

它代表动态主机配置协议，为主机分配 IP 地址、子网掩码和网关。它是这样工作的：

* 主机在进入网络时广播一条寻找 DHCP 服务器的信息（DHCP DISCOVER）。
* DHCP 服务器会以数据包的形式发回要约信息，其中包含租用时间、子网掩码、IP 地址等信息（DHCP OFFER）。
* 根据接受的提议，客户端会发送回复广播，让所有 DHCP 服务器都知道（DHCP 请求）。
* 服务器发送确认（DHCP ACK）

更多信息 [此处](https://linuxjourney.com/lesson/dhcp-overview)
</b></details>

<details>
<summary>同一个网络中可以有两个 DHCP 服务器吗？它是如何工作的？</summary><br><b>

可以在同一网络上安装两个 DHCP 服务器，但不建议这样做，而且必须仔细配置，以防止冲突和配置问题。
- 在同一网络上配置两个 DHCP 服务器时，两个服务器都有可能为同一设备分配 IP 地址和其他网络配置设置，从而导致冲突和连接问题。此外，如果 DHCP 服务器配置了不同的网络设置或选项，网络上的设备可能会收到冲突或不一致的配置设置。
- 不过，在某些情况下，可能有必要在同一网络中设置两个 DHCP 服务器，例如在大型网络中，一个 DHCP 服务器可能无法处理所有请求。在这种情况下，可以将 DHCP 服务器配置为不同的 IP 地址范围或不同的子网，这样它们就不会相互干扰。
</b></details>

<details>
<summary>什么是 SSL 隧道？它是如何工作的？</summary><br><b>

- SSL（安全套接字层）隧道是一种技术，用于在互联网等不安全网络上的两个端点之间建立安全的加密连接。SSL 隧道是通过将流量封装在 SSL 连接中创建的，SSL 连接可提供保密性、完整性和身份验证。

下面介绍 SSL 隧道的工作原理：

1. 客户端启动与服务器的 SSL 连接，其中包括建立 SSL 会话的握手过程。
2. SSL 会话建立后，客户端和服务器会协商加密参数，如加密算法和密钥长度，然后交换数字证书，以验证彼此的身份。
3. 客户端随后通过 SSL 隧道将流量发送到服务器，服务器解密流量并将其转发到目标位置。
4. 服务器通过 SSL 隧道将流量发送回客户端，客户端对流量进行解密并将其转发给应用程序。
</b></details>

<details>
<summary>什么是套接字？在哪里可以看到系统中的套接字列表？</summary><br><b>

- 套接字是一种软件端点，可使进程之间通过网络进行双向通信。套接字为网络通信提供了一个标准化接口，允许应用程序在网络上发送和接收数据。查看 Linux 系统上打开的套接字列表：
***netstat -an***
- 该命令显示所有打开套接字的列表，以及它们的协议、本地地址、外来地址和状态。
</b></details>

<details>
<summary>什么是 IPv6？如果我们有 IPv4，为什么还要考虑使用它？</summary><br><b>

- IPv6（互联网协议版本 6）是互联网协议（IP）的最新版本，用于识别网络上的设备并与之通信。IPv6 地址是 128 位地址，用十六进制表示，如 2001:0db8:85a3:0000:0000:8a2e:0370:7334。

我们应该考虑使用 IPv6 而不是 IPv4 有几个原因：

1. 地址空间：IPv4 的地址空间有限，在世界上许多地方已经耗尽。IPv6 提供了更大的地址空间，可提供数万亿个唯一的 IP 地址。
2. 安全性：IPv6 包含对 IPsec 的内置支持，为网络流量提供端到端加密和身份验证。
3. 性能：IPv6 包括一些有助于提高网络性能的功能，例如组播路由，它允许将一个数据包同时发送到多个目的地。
4. 简化网络配置：IPv6 包含可简化网络配置的功能，例如无状态自动配置，它允许设备自动配置自己的 IPv6 地址，而无需 DHCP 服务器。
5. 更好的移动性支持：IPv6 包含可改进移动性支持的功能，如移动 IPv6，它允许设备在不同网络之间移动时保持其 IPv6 地址。
</b></details>

<details>
<summary>什么是 VLAN？</summary><br><b>

- VLAN（虚拟局域网）是一种逻辑网络，它将物理网络上的一组设备组合在一起，而不管它们的物理位置如何。创建 VLAN 的方法是配置网络交换机，为连接到交换机上特定端口或端口组的设备发送的帧分配特定的 VLAN ID。
</b></details>

<details>
<summary>什么是 MTU？</summary><br><b>
	
MTU 是最大传输单元（Maximum Transmission Unit）的缩写。它是指单个事务中可发送的最大 PDU（协议数据单元）的大小。
</b></details>

<details>
<summary>如果发送的数据包大于 MTU，会发生什么情况？</summary><br><b>
	
在 IPv4 协议中，路由器可以对 PDU 进行分片，然后通过事务发送所有已分片的 PDU。
	
使用 IPv6 协议时，它会向用户计算机发出错误信息。
</b></details>

<details>
<summary>真还是假？Ping 使用 UDP 是因为它不在乎连接是否可靠</summary><br><b>

错。Ping 实际上使用的是 ICMP（互联网控制报文协议），这是一种用于发送与网络通信有关的诊断信息和控制信息的网络协议。
</b></details>

<details>
<summary>什么是 SDN？</summary><br><b>

- SDN 是软件定义网络（Software-Defined Networking）的缩写。它是一种网络管理方法，强调网络控制的集中化，使管理员能够通过软件抽象来管理网络行为。
- 在传统网络中，路由器、交换机和防火墙等网络设备需要使用专用软件或命令行界面进行单独配置和管理。相比之下，SDN 将网络控制平面与数据平面分开，允许管理员通过集中式软件控制器管理网络行为。
</b></details>

<details>
<summary>什么是 ICMP？它有什么用途？</summary><br><b>

- ICMP 是 Internet Control Message Protocol 的缩写。它是 IP 网络中用于诊断和控制的协议。它是互联网协议套件的一部分，在网络层运行。

ICMP消息被用于各种目的，包括：
1. 错误报告：ICMP消息用于报告网络中发生的错误，例如无法将数据包传递到其目的地。
2. Ping：ICMP 用于发送 ping 信息，该信息用于测试主机或网络是否可连接，并测量数据包的往返时间。
3. 路径 MTU 发现：ICMP 用于发现路径的最大传输单元（MTU），即无需分片即可传输的最大数据包大小。
4. 跟踪路由跟踪路由实用程序使用 ICMP 跟踪数据包通过网络的路径。
5. 路由器发现ICMP 用于发现网络中的路由器。
</b></details>

<details>
<summary>什么是 NAT？它是如何工作的？</summary><br><b>

NAT 是网络地址转换的缩写。它是一种在传输信息前将多个本地专用地址映射到一个公共地址的方法。希望多个设备使用一个 IP 地址的组织和大多数家用路由器一样，都会使用 NAT。
例如，你电脑的私有 IP 可能是 192.168.1.100，但你的路由器会将流量映射到它的公共 IP（如 1.1.1.1）。互联网上的任何设备都会看到来自公共 IP（1.1.1.1）而不是私人 IP（192.168.1.100）的流量。
</b></details>

<details>
<summary>下列协议中使用的端口号分别是？

  * SSH
  * SMTP
  * HTTP
  * DNS
  * HTTPS
  * FTP
  * SFTP
</summary><br><b>

  * SSH - 22
  * SMTP - 25
  * HTTP - 80
  * DNS - 53
  * HTTPS - 443
  * FTP - 21
  * SFTP - 22
</b></details>

<details>
<summary>哪些因素会影响网络性能？</summary><br><b>

有几个因素会影响网络性能，包括：

1. 带宽：网络连接的可用带宽会极大地影响其性能。带宽有限的网络可能会出现数据传输速率慢、延迟高和响应速度差等问题。
2. 延迟：延迟是指数据从网络中的一个点传输到另一个点时发生的延迟。高延迟会导致网络性能缓慢，尤其是视频会议和在线游戏等实时应用。
3. 网络拥塞：当太多设备同时使用网络时，就会出现网络拥塞，导致数据传输速率缓慢和网络性能低下。
4. 数据包丢失：当数据包在传输过程中丢失时，就会出现丢包现象。这会导致网络速度变慢，整体网络性能降低。
5. 网络拓扑：网络的物理布局，包括交换机、路由器和其他网络设备的位置，都会影响网络性能。
6. 网络协议：不同的网络协议具有不同的性能特征，会影响网络性能。例如，TCP 是一种可靠的协议，可以保证数据的传输，但也会因错误检查和重传所需的开销而导致性能降低。
7. 网络安全：防火墙和加密等安全措施会影响网络性能，尤其是在需要大量处理能力或引入额外延迟的情况下。
8. 距离：网络设备之间的物理距离会影响网络性能，尤其是无线网络，信号强度和干扰会影响连接性和数据传输速率。
</b></details>

<details>
<summary>什么是 APIPA？</summary><br><b>

APIPA 是分配给设备的一组 IP 地址
当主 DHCP 服务器无法访问时分配给设备的 IP 地址

</b></details>

<details>
<summary>APIPA 使用哪个 IP 范围？</summary><br><b>

APIPA 使用的 IP 范围是169.254.0.1 - 169.254.255.254.

</b></details>

#### 控制平面和数据平面

<details>
<summary>"控制平面"是指什么？</summary><br><b>

控制平面是网络的一部分，它决定如何将数据包路由和转发到不同的位置。
</b></details>

<details>
<summary>数据平面 "指的是什么？</summary><br><b>

数据平面是网络中实际转发数据/数据包的部分。
</b></details>

<details>
<summary>管理平面 "指的是什么？</summary><br><b>

它指的是监测和管理功能。
</b></details>

<details>
<summary>创建路由表属于哪个平面（数据、控制......）？</summary><br><b>

控制平面。
</b></details>

<details>
<summary>解释生成树协议（STP）。</summary><br><b>
</b></details>

<details>
<summary>什么是链路聚合？为什么要使用？</summary><br><b>
</b></details>

<details>
<summary>什么是非对称路由？如何处理？</summary><br><b>
</b></details>

<details>
<summary>您熟悉哪些覆盖（隧道）协议？</summary><br><b>
</b></details>

<details>
<summary>什么是 GRE？它是如何运作的？</summary><br><b>
</b></details>

<details>
<summary>什么是 VXLAN？它是如何工作的？</summary><br><b>
</b></details>

<details>
<summary>什么是 SNAT？</summary><br><b>
</b></details>

<details>
<summary>解释 OSPF。</summary><br><b>


OSPF（开放式最短路径优先）是一种路由协议，可在各种类型的路由器上实施。一般来说，大多数现代路由器都支持 OSPF，包括思科、瞻博网络和华为等供应商的路由器。该协议设计用于基于 IP 的网络，包括 IPv4 和 IPv6。此外，它采用分层网络设计，将路由器分组为区域，每个区域都有自己的拓扑图和路由表。这种设计有助于减少路由器之间需要交换的路由信息量，提高网络的可扩展性。

OSPF 4 路由器类型有
  * Internal Router
  * Area Border Routers
  * Autonomous Systems Boundary Routers
  * Backbone Routers

  了解有关 OSPF 路由器类型的更多信息： https://www.educba.com/ospf-router-types
</b></details>

<details>
<summary>什么是延迟？</summary><br><b>
	
延迟是指信息从信息源到达目的地所需的时间。
</b></details>

<details>
<summary>什么是带宽？</summary><br><b>
	
带宽是通信信道的容量，用于衡量后者在特定时间段内可处理的数据量。带宽越大，意味着处理的流量越多，数据传输量也就越大。
</b></details>

<details>
<summary>什么是吞吐量？</summary><br><b>
	
吞吐量是指在一定时间内通过任何传输通道传输的实际数据量。
</b></details>

<details>
<summary>在进行搜索查询时，延迟和吞吐量哪个更重要？如何确保我们对全球基础设施进行管理？
</summary><br><b>

延迟。要获得良好的延迟，搜索查询应转发到最近的数据中心。
</b></details>

<details>
<summary>上传视频时，延迟和吞吐量哪个更重要？如何确保这一点？</summary><br><b>

吞吐量。为获得良好的吞吐量，上传数据流应被路由到未充分利用的链路。
</b></details>

<details>
<summary>转发请求时还需要考虑哪些因素（除了延迟和吞吐量）？</summary><br><b>

* 保持缓存更新（这意味着请求可能不会被转发到最近的数据中心）
</b></details>

<details>
<summary>解释 Spine & Leaf</summary><br><b>
</b></details>

<details>
<summary>什么是网络拥塞？什么原因会导致网络拥塞？</summary><br><b>

当网络上需要传输的数据过多，而网络容量不足以满足需求时，就会出现网络拥塞。 </br>
这会导致延迟和数据包丢失增加。原因可能是多方面的，如网络使用率高、文件传输量大、恶意软件、硬件问题或网络设计问题。</br>
为防止网络拥塞，必须监控网络使用情况，并实施策略来限制或管理需求。
</b></details>

<details>
<summary>关于 UDP 数据包格式，您能告诉我什么？TCP 数据包格式如何？有何不同？</summary><br><b>
</b></details>

<details>
<summary>什么是指数后退算法？在哪里使用？</summary><br><b>
</b></details>

<details>
<summary>使用汉明码，以下数据字 100111010001101 的码字是什么？</summary><br><b>

00110011110100011101
</b></details>

<details>
<summary>举例说明应用层中的协议</summary><br><b>

* 超文本传输协议（HTTP）--用于互联网上的网页
* 简单邮件传输协议（SMTP）--用于电子邮件传输
* 电信网络（TELNET）--终端模拟，允许客户端访问 telnet 服务器
* 文件传输协议（FTP）--便于在任何两台机器之间传输文件
* 域名系统 (DNS) - 域名转换
* 动态主机配置协议（DHCP）--为主机分配 IP 地址、子网掩码和网关
* 简单网络管理协议（SNMP）--收集网络设备数据
</b></details>

<details>
<summary>举例说明网络层中的协议</summary><br><b>

* 互联网协议 (IP) - 协助将数据包从一台机器路由到另一台机器
* 互联网控制消息协议（ICMP）--让人知道发生了什么，如错误信息和调试信息
</b></details>

<details>
<summary>什么是 HSTS？</summary><br><b>
HTTP 严格传输安全（HTTP Strict Transport Security）是一种网络服务器指令，它通过在开始时发送并返回给浏览器的响应标头，告知用户代理和网络浏览器如何处理其连接。这将强制通过 HTTPS 加密连接，忽略任何脚本通过 HTTP 加载该域中任何资源的调用。

阅读更多 [此处](https://www.globalsign.com/en/blog/what-is-hsts-and-how-do-i-use-it#:~:text=HTTP%20Strict%20Transport%20Security%20(HSTS,and%20back%20to%20the%20browser.)
</b></details>

#### 网络 - 其他

<details>
<summary>什么是互联网？它和万维网一样吗？</summary><br><b>

互联网是一个由网络组成的网络，在全球范围内传输大量数据。<br>
万维网是一个运行在数百万服务器上的应用程序，它位于互联网之上，可通过所谓的网络浏览器访问
</b></details>

<details>
<summary>什么是ISP?</summary><br><b>

ISP（互联网服务提供商）是当地的互联网公司。
</b></details>

## 操作系统

### 操作系统练习

|名称|主题|目标和说明|解决方案|评论
|--------|--------|------|----|----|
|fork 101|fork|[链接](topics/os/fork_101.md)|[链接](topics/os/solutions/fork_101_solution.md)
|Fork 102|Fork|[链接](topic/os/fork_102.md)|[链接](topic/os/solutions/fork_102_solution.md)

### 操作系统 - 自我评估

<details>
<summary>什么是操作系统？</summary><br><b>

来自书籍《操作系统：轻松三步》：

它 "负责使程序的运行变得简单（甚至允许你同时运行多个程序），允许程序共享内存，使程序能够与设备交互，以及其他类似的有趣功能"。
</b></details>

#### 操作系统 - 进程

<details>
<summary>你能解释一下什么是流程吗？</summary><br><b>

进程是一个正在运行的程序。程序是一条或多条指令，程序（或进程）由操作系统执行。
</b></details>

<details>
<summary>如果要为操作系统中的进程设计一个应用程序接口，这个应用程序接口会是什么样的？</summary><br><b>

它将支持以下工作：

* 创建 - 允许创建新流程
* 删除 - 允许删除/销毁进程
* 状态 - 允许检查进程的状态，是否正在运行、停止、等待等。
* 停止 - 允许停止正在运行的进程
</b></details>

<details>
<summary>如何创建流程？</summary><br><b>

* 操作系统正在读取程序代码和其他相关数据
* 程序代码被载入内存，更确切地说，是载入进程的地址空间。
* 为程序的堆栈（又称运行时堆栈）分配内存。堆栈也由操作系统初始化，其中包含 argv、* argc 和 main() 的参数等数据。
* 为程序的堆分配内存，用于动态分配数据，如数据结构链表和哈希表。
* 执行 I/O 初始化任务，如在基于 Unix/Linux 的系统中，每个进程都有 3 个文件描述* 符（输入、输出和错误）。
* 操作系统从 main() 开始运行程序
</b></details>

<details>
<summary>真还是假？将程序加载到内存的过程是急切的（一次性完成）</summary><br><b>

错。过去是这样，但现在的操作系统执行懒加载，即只先加载进程运行所需的相关部分。
</b></details>

<details>
<summary>流程有哪些不同状态？</summary><br><b>

* 运行 - 正在执行指令
* 就绪 - 已准备好运行，但由于各种原因被搁置
* 阻塞 - 等待某些操作完成。例如 I/O 磁盘请求
</b></details>

<details>
<summary>流程受阻的原因有哪些？</summary><br><b>

  - 输入/输出操作（如从磁盘读取数据）
  - 等待来自网络的数据包
</b></details>

<details>
<summary>什么是进程间通信（IPC）？</summary><br><b>
</b></details>

<details>
<summary>什么是 "时间共享"？</summary><br><b>

即使系统只有一个物理 CPU，也可以允许多个用户在上面工作和运行程序。这可以通过时间共享来实现，在用户看来，系统有多个 CPU，但实际上只是通过应用多程序和多任务来共享一个 CPU。
</b></details>

<details>
<summary>什么是 "空间共享"？</summary><br><b>

与时间共享有点相反。在时间共享中，一个实体使用一段时间后，另一个实体可以使用相同的资源；而在空间共享中，多个实体共享空间，但空间不在它们之间转移。<br>
它被一个实体使用，直到这个实体决定将其处理掉。以存储为例。在存储中，一个文件是属于你的，直到你决定删除它。
</b></details>

<details>
<summary>是哪个组件决定了哪个进程在特定时间运行？</summary><br><b>

CPU 调度程序
</b></details>

#### 操作系统 - 内存

<details>
<summary>什么是 "虚拟内存"，它有什么作用？</summary><br><b>

虚拟内存将计算机的 RAM 与硬盘上的临时空间相结合。当内存不足时，虚拟内存会帮助将数据从内存移动到一个名为分页文件的空间。将数据移至分页文件可以释放内存，让电脑完成工作。一般来说，内存越大，程序运行速度越快。
https://www.minitool.com/lib/virtual-memory.html
</b></details>

<details>
<summary>什么是需求寻呼？</summary><br><b>
</b></details>

<details>
<summary>什么是随写随抄？</summary><br><b>
写入时复制（COW）是一种资源管理概念，目的是减少不必要的信息复制。这一概念在 POSIX fork 系统调用中得到了实现，它可以为调用进程创建一个复制进程。

这个想法：
1. 如果 2 个或更多实体之间共享资源（例如 2 个进程之间共享内存段），则不需要为每个实体复制资源，而是每个实体都拥有对共享资源的 READ 操作访问权限。(共享段被标记为只读）。
(可以认为每个实体都有一个指向共享资源位置的指针，可以取消引用来读取其值）
2. 如果一个实体对共享资源执行写入操作，就会出现问题，因为共享资源的所有其他实体也将永久更改该资源。
(想想一个进程修改了堆栈上的某些变量，或在堆上动态分配了某些数据，这些对共享资源的更改也将适用于所有其他进程，这绝对是一种不可取的行为）。
3. 作为一种解决方案，只有当要对共享资源执行写入操作时，该资源才会首先被复制，然后更改才会被应用。
</b></details>

<details>
<summary>什么是内核，它有什么作用？</summary><br><b>

内核是操作系统的一部分，负责执行以下任务：

  * 分配内存
  * 安排流程
  * 控制 CPU
</b></details>

<details>
<summary>真还是假？内核中的部分代码被加载到内存的保护区域，因此应用程序无法覆盖它们</summary><br><b>

真的
</b></details>

<details>
<summary>什么是 POSIX？</summary><br><b>
</b></details>

<details>
<summary>解释什么是 Semaphore 及其在操作系统中的作用</summary><br><b>
</b></details>

<details>
<summary>什么是缓存？什么是缓冲区？</summary><br><b>

缓冲区：内存中用于临时保存数据的预留位置
缓存：缓存通常用于读取和写入磁盘的过程，通过使不同程序所使用的类似数据易于访问来加快处理速度。
</b></details>

## 虚拟化

<details>
<summary>什么是虚拟化？</summary><br><b>

虚拟化利用软件在计算机硬件上创建一个抽象层，允许将单台计算机的硬件元素--处理器、内存、存储等--划分为多台虚拟计算机，通常称为虚拟机（VM）。
</b></details>

<details>
<summary>什么是管理程序？</summary><br><b>

Red Hat："管理程序是创建和运行虚拟机（VM）的软件。管理程序有时也称为虚拟机监控程序（VMM），它将管理程序操作系统和资源与虚拟机隔离开来，并实现对这些虚拟机的创建和管理"。

更多信息 [此处](https://www.redhat.com/en/topics/virtualization/what-is-a-hypervisor)
</b></details>

<details>
<summary>有哪些类型的管理程序？</summary><br><b>

托管管理程序和裸机管理程序。
</b></details>

<details>
<summary>与托管管理程序相比，裸机管理程序有哪些优缺点？</summary><br><b>

由于拥有自己的驱动程序并可直接访问硬件组件，裸机管理程序通常具有更好的性能、稳定性和可扩展性。

另一方面，加载（任何）驱动程序可能会受到一些限制，因此托管管理程序通常会受益于更好的硬件兼容性。
</b></details>

<details>
<summary>虚拟化有哪些类型？</summary><br><b>

操作系统虚拟化
网络功能虚拟化
桌面虚拟化
</b></details>

<details>
<summary>容器化是虚拟化的一种吗？</summary><br><b>

是的，这是一种操作系统级的虚拟化，内核是共享的，允许使用多个孤立的用户空间实例。
</b></details>

<details>
<summary>虚拟机的引入如何改变了行业和应用程序的部署方式？</summary><br><b>

虚拟机的引入使公司能够在同一硬件上部署多个业务应用程序，同时以安全的方式将每个应用程序相互分离，每个应用程序都运行在各自独立的操作系统上。
</b></details>

#### 虚拟机

<details>
<summary>在容器时代，我们还需要虚拟机吗？它们还有意义吗？</summary><br><b>

是的，即使在容器时代，虚拟机仍然具有现实意义。虽然容器为虚拟机提供了轻量级和可移植的替代品，但它们确实存在一定的局限性。虚拟机仍然重要，因为它们提供了隔离性和安全性，可以运行不同的操作系统，而且适合传统应用程序。例如，容器的局限在于共享主机内核。
</b></details>

## Prometheus

<details>
<summary>什么是Prometheus？Prometheus有哪些主要特点？</summary><br><b>

Prometheus 是一款流行的开源系统监控和警报工具包，最初由 SoundCloud 开发。它旨在收集和存储时间序列数据，并允许使用一种名为 PromQL 的强大查询语言对这些数据进行查询和分析。Prometheus 常用于监控云原生应用程序、微服务和其他现代基础设施。

Prometheus 的一些主要功能包括

    1.数据模型：Prometheus 采用灵活的数据模型，允许用户根据自己的具体使用情况，以合理的方式组织和标注时间序列数据。标签用于识别数据的不同维度，如数据来源或数据收集环境。

    2.基于拉动的架构：Prometheus 采用基于拉动的模式从目标收集数据，这意味着 Prometheus 服务器会定期主动向目标查询指标数据。这种架构比基于推送的模式更具可扩展性和可靠性，后者要求每个目标都向服务器推送数据。

    3.时间序列数据库：Prometheus 将其所有数据存储在一个时间序列数据库中，允许用户在时间范围内执行查询，并以各种方式汇总和分析数据。该数据库针对写入量大的工作负载进行了优化，能够以较低的延迟处理大量数据。

    4.警报：Prometheus 包含一个功能强大的警报系统，允许用户根据其指标数据定义规则，并在满足特定条件时发送警报。警报可通过电子邮件、聊天或其他渠道发送，并可进行定制，以包括有关问题的具体细节。

    5.可视化：Prometheus 有一个名为 PromDash 的内置图表和可视化工具，允许用户创建自定义仪表盘来监控系统和应用程序。PromDash 支持多种图表类型和可视化选项，并可使用 CSS 和 JavaScript 进行自定义。

总之，Prometheus 是一款强大而灵活的工具，可用于监控和分析系统及应用程序，并在业界广泛用于云原生监控和可观测性。

</b></details>

<details>
<summary>在哪些情况下，不使用Prometheus可能会更好？</summary><br><b>

摘自 Prometheus 文档："如果您需要 100% 的准确性，例如按请求计费"。
</b></details>

<details>
<summary>描述 Prometheus 架构和组件</summary><br><b>

Prometheus架构由四个主要组件组成：

    1. Prometheus 服务器：Prometheus 服务器负责收集和存储度量数据。它有一个简单的内置存储层，可将时间序列数据存储在按时间排序的数据库中。

    2. 客户端库：Prometheus 提供一系列客户端库，使应用程序能够以 Prometheus 服务器可摄取的格式公开其度量数据。这些库适用于各种编程语言，包括 Java、Python 和 Go。

    3. 导出器：导出器是一种软件组件，用于从第三方系统中导出现有度量指标，供 Prometheus 服务器摄取。Prometheus 为 MySQL、PostgreSQL 和 Apache 等一系列流行技术提供了导出器。

    4. 警报管理器Alertmanager 组件负责处理 Prometheus 服务器生成的警报。它可以处理来自多个来源的警报，并提供一系列功能，用于重复、分组和将警报路由到适当的通道。

总体而言，Prometheus 架构设计具有高度可扩展性和弹性。服务器和客户端库可以分布式部署，以支持在大规模、高动态环境中进行监控
</b></details>

<details>
<summary>您能否将 Prometheus 与 InfluxDB 等其他解决方案进行比较？</summary><br><b>

与 InfluxDB 等其他监控解决方案相比，Prometheus 以其高性能和可扩展性而著称。它可以处理大量数据，并能与监控生态系统中的其他工具轻松集成。InfluxDB 则以易用性和简单性著称。它拥有友好的用户界面，并提供易于使用的 API 来收集和查询数据。

另一种流行的解决方案是 Nagios，它是一种更传统的监控系统，依靠基于推送的模式来收集数据。Nagios 由来已久，以其稳定性和可靠性著称。不过，与 Prometheus 相比，Nagios 缺少一些更先进的功能，如多维数据模型和强大的查询语言。

总之，监控解决方案的选择取决于企业的具体需求和要求。Prometheus 是大规模监控和警报的最佳选择，而 InfluxDB 可能更适合需要易用性和简单性的小型环境。对于优先考虑稳定性和可靠性而非高级功能的企业来说，Nagios 仍然是一个可靠的选择。
</b></details>

<details>
<summary>什么是警报？</summary><br><b>
在 Prometheus 中，警报是在满足特定条件或阈值时触发的通知。警报可配置为在某些指标超过某个阈值或发生特定事件时触发。警报触发后，可通过电子邮件、呼叫器或聊天等各种渠道通知相关团队或个人采取适当行动。警报是任何监控系统的重要组成部分，因为它们能让团队在问题影响用户或导致系统停机之前主动发现并做出响应。
</b></details>

<details>
<summary>什么是实例？什么是作业？</summary><br><b>

在 Prometheus 中，实例指的是被监控的单个目标。例如，单个服务器或服务。作业是指执行相同功能的一组实例，例如为相同应用程序提供服务的一组网络服务器。作业允许您定义和管理一组目标。

从本质上讲，实例是 Prometheus 收集指标的单个目标，而作业则是可作为一组进行管理的类似实例的集合。
</b></details>

<details>
<summary>Prometheus 支持哪些核心指标类型？</summary><br><b>
Prometheus 支持多种类型的度量，包括

    1.计数器：用于跟踪事件或样本计数的单调递增值。例如，已处理的请求数或遇到的错误总数。

    2.仪表：可上升或下降的值，如 CPU 使用率或内存使用率。与计数器不同的是，仪表值可以是任意的，这意味着它们可以根据被监控系统的变化而上升或下降。

    3.直方图：根据观测值或事件值划分的一组观测值或事件。直方图有助于分析指标的分布，如请求延迟或响应大小。

    4.摘要：摘要与直方图类似，但它提供的不是桶，而是一组观测值的量化值。摘要有助于监控请求延迟或响应大小在一段时间内的分布情况。

Prometheus 还支持用于汇总和操作指标的各种函数和运算符，如总和、最大值、最小值和速率。这些功能使其成为监控和警报系统指标的强大工具。
</b></details>

<details>
<summary>什么是出口商？它有什么用途？</summary><br><b>
导出器是第三方系统或应用程序与 Prometheus 之间的桥梁，使 Prometheus 能够监控和收集来自该系统或应用程序的数据。

导出器充当服务器，在特定的网络端口上监听 Prometheus 提出的度量数据采集请求。它从第三方系统或应用程序中收集指标，并将其转换为 Prometheus 可以理解的格式。然后，导出器通过 HTTP 端点将这些指标导出到 Prometheus，供其收集和分析。

导出器通常用于监控数据库、网络服务器和存储系统等各类基础设施组件。例如，有一些输出程序可用于监控 MySQL 和 PostgreSQL 等常用数据库，以及 Apache 和 Nginx 等网络服务器。

总之，出口程序是 Prometheus 生态系统的重要组成部分，可对各种系统和应用程序进行监控，并为平台提供高度的灵活性和可扩展性。
</b></details>

<details>
<summary>哪些 Prometheus 最佳实践？</summary><br><b>
下面是其中的三个：

    1.仔细标注：仔细、一致地标注度量指标对于有效查询和警报至关重要。标签应清晰、简洁，并包含指标的所有相关信息。

    2.保持指标简单：导出器显示的度量指标应简单明了，重点关注被监控系统的单一方面。这有助于避免混淆，并确保团队所有成员都能轻松理解度量指标。

    3.谨慎使用警报功能：虽然警报是 Prometheus 的一项强大功能，但应谨慎使用，仅用于最关键的问题。设置过多的警报会导致警报疲劳，并导致重要警报被忽视。建议只设置最重要的警报，并根据警报的实际频率逐步调整阈值。
</b></details>

<details>
<summary>如何获取特定时间内的总请求数？</summary><br><b>
要使用 Prometheus 获取给定时间段内的总请求数，可以使用求和函数和速率函数。下面是一个查询示例，可以显示过去一小时内的请求总数：

```
sum(rate(http_requests_total[1h]))
```
在这个查询中，http_requests_total 是跟踪 HTTP 请求总数的指标名称，而速率函数计算的是过去一小时内每秒的请求速率。然后，求和函数将所有请求相加，得出最后一小时的请求总数。

您可以通过更改速率函数中的持续时间来调整时间范围。例如，如果要获取最近一天的请求总数，可以将函数改为 rate(http_requests_total[1d])*。
</b></details>

<details>
<summary>Prometheus中的HA是什么意思？</summary><br><b>

HA 代表高可用性。这意味着，即使在出现故障或其他问题时，系统也能高度可靠并始终可用。在实践中，这通常涉及设置 Prometheus 的多个实例，并确保它们全部同步，能够无缝协同工作。这可以通过负载平衡、复制和故障转移机制等多种技术来实现。通过在 Prometheus 中实施 HA，用户可以确保其监控数据始终可用并保持最新，即使面对硬件或软件故障、网络问题或其他可能导致停机或数据丢失的问题也是如此。
</b></details>

<details>
<summary>如何连接两个指标？</summary><br><b>
在Prometheus中，可以使用join()函数来实现两个指标的连接。join()函数根据它们的标签值将两个或多个时间序列合并在一起。它有两个必需参数：on和table*。on参数指定要连接的标签，而table参数指定要连接的时间序列。

下面是一个如何使用 join() 函数连接两个度量指标的示例：

```
sum_series(
  join(
    on(service, instance) request_count_total,
    on(service, instance) error_count_total,
  )
)
```
在此示例中，join() 函数根据服务和实例标签值合并了 request_count_total 和 error_count_total 时间序列。然后，sum_series() 函数计算所得到的时间序列的总和
</b></details>

<details>
<summary>如何编写返回标签值的查询？
要在 Prometheus 中编写返回标签值的查询，可以使用 label_values 函数。label_values 函数有两个参数：标签名称和度量名称。

例如，如果您有一个名为 *http_requests_total* 的度量指标，其标签名为 *method*，而您想返回 *method* 标签的所有值，可以使用下面的查询：

```
label_values(http_requests_total, method)
```

这将返回 *http_requests_total* 度量中方法标签的所有值的列表。然后，您可以在进一步查询中使用该列表或过滤数据。
</b></details>

<details>
<summary>如何将 cpu_user_seconds 转换为 cpu 使用百分比？</summary><br><b>
要将 *cpu_user_seconds* 转换为 CPU 使用百分比，需要将其除以总耗时和 CPU 内核数，然后乘以 100。计算公式如下

```
100 * sum(rate(process_cpu_user_seconds_total{job="<job-name>"}[<time-period>])) by (instance) / (<time-period> * <num-cpu-cores>)
```

其中，<job-name> 是要查询的作业名称，<time-period> 是要查询的时间范围（如 5m*, 1h*），<num-cpu-cores> 是要查询的计算机 CPU 内核数。

例如，要获取在有 4 个 CPU 内核的机器上运行的名为 *my-job* 的作业在过去 5 分钟内的 CPU 使用百分比，可以使用下面的查询：

```
100 * sum(rate(process_cpu_user_seconds_total{job="my-job"}[5m])) by (instance) / (5m * 4)
```
</b></details>